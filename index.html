<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>tqdm by tqdm</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">tqdm</h1>
        <p class="header">minimal overhead highly customisable progress bar</p>



        <ul>
          <li><a class="buttons github" href="https://github.com/tqdm">GitHub Profile</a></li>
        </ul>

      </header>
      <section>
        <p><img src="https://raw.githubusercontent.com/tqdm/tqdm/master/logo.png" alt="Logo"></p>

<h1>
<a id="tqdm" class="anchor" href="#tqdm" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>tqdm</h1>

<p><a href="https://pypi.python.org/pypi/tqdm"><img src="https://img.shields.io/pypi/v/tqdm.svg" alt="PyPi-Status"></a>
<a href="https://pypi.python.org/pypi/tqdm"><img src="https://img.shields.io/pypi/pyversions/tqdm.svg" alt="PyPi-Versions"></a></p>

<p><a href="https://travis-ci.org/tqdm/tqdm"><img src="https://travis-ci.org/tqdm/tqdm.svg?branch=master" alt="Build-Status"></a>
<a href="https://coveralls.io/r/tqdm/tqdm"><img src="https://coveralls.io/repos/tqdm/tqdm/badge.svg" alt="Coverage-Status"></a>
<a href="https://codecov.io/github/tqdm/tqdm?branch=master"><img src="https://codecov.io/github/tqdm/tqdm/coverage.svg?branch=master" alt="Branch-Coverage-Status"></a></p>

<p><a href="https://zenodo.org/badge/latestdoi/21637/tqdm/tqdm"><img src="https://zenodo.org/badge/21637/tqdm/tqdm.svg" alt="DOI-URI"></a>
<a href="https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE"><img src="https://img.shields.io/pypi/l/tqdm.svg" alt="Licence"></a></p>

<p><code>tqdm</code> (read taqadum, تقدّم) means "progress" in arabic.</p>

<p>Instantly make your loops show a smart progress meter - just wrap any
iterable with "tqdm(iterable)", and you're done!</p>

<pre lang="sourceCode"><code>from tqdm import tqdm
for i in tqdm(range(9)):
    ...
</code></pre>

<p>Here's what the output looks like:</p>

<p><code>76%|████████████████████████████         | 7568/10000 [00:33&lt;00:10, 229.00it/s]</code></p>

<p><code>trange(N)</code> can be also used as a convenient shortcut for
<code>tqdm(xrange(N))</code>.</p>

<p><img src="https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm.gif" alt="Screenshot"></p>

<p>It can also be executed as a module with pipes:</p>

<pre lang="sourceCode"><code>$ seq 9999999 | tqdm --unit_scale | wc -l
10.0Mit [00:02, 3.58Mit/s]
9999999
</code></pre>

<p>Overhead is low -- about 60ns per iteration (80ns with <code>tqdm_gui</code>), and
is unit tested against performance regression. By comparison, the well
established
<a href="https://github.com/niltonvolpato/python-progressbar">ProgressBar</a> has
an 800ns/iter overhead.</p>

<p>In addition to its low overhead, <code>tqdm</code> uses smart algorithms to predict
the remaining time and to skip unnecessary iteration displays, which
allows for a negligible overhead in most cases.</p>

<p><code>tqdm</code> works on any platform (Linux, Windows, Mac, FreeBSD,
Solaris/SunOS), in any console or in a GUI, and is also friendly with
IPython/Jupyter notebooks.</p>

<p><code>tqdm</code> does not require any library (not even curses!) to run, just a
vanilla Python interpreter will do and an environment supporting
<code>carriage return \r</code> and <code>line feed \n</code> control characters.</p>

<hr>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h2>

<h3>
<a id="latest-pypi-stable-release" class="anchor" href="#latest-pypi-stable-release" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Latest pypi stable release</h3>

<p><a href="https://pypi.python.org/pypi/tqdm"><img src="https://img.shields.io/pypi/v/tqdm.svg" alt="PyPi-Status"></a></p>

<pre lang="sourceCode"><code>pip install tqdm
</code></pre>

<h3>
<a id="latest-development-release-on-github" class="anchor" href="#latest-development-release-on-github" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Latest development release on github</h3>

<p><a href="https://github.com/tqdm/tqdm/releases"><img src="https://img.shields.io/github/tag/tqdm/tqdm.svg?maxAge=2592000" alt="Github-Status"></a>
<a href="https://github.com/tqdm/tqdm/stargazers"><img src="https://img.shields.io/github/stars/tqdm/tqdm.svg" alt="Github-Stars"></a>
<a href="https://github.com/tqdm/tqdm/network"><img src="https://img.shields.io/github/forks/tqdm/tqdm.svg" alt="Github-Forks"></a></p>

<p>Pull and install in the current directory:</p>

<pre lang="sourceCode"><code>pip install -e git+https://github.com/tqdm/tqdm.git@master#egg=tqdm
</code></pre>

<h2>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changelog</h2>

<p>The list of all changes is available either on Github's Releases:
<a href="https://github.com/tqdm/tqdm/releases"><img src="https://img.shields.io/github/tag/tqdm/tqdm.svg?maxAge=2592000" alt="Github-Status"></a>
or on crawlers such as
<a href="https://allmychanges.com/p/python/tqdm/">allmychanges.com</a>.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h2>

<p><code>tqdm</code> is very versatile and can be used in a number of ways. The three
main ones are given below.</p>

<h3>
<a id="iterable-based" class="anchor" href="#iterable-based" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Iterable-based</h3>

<p>Wrap <code>tqdm()</code> around any iterable:</p>

<pre lang="sourceCode"><code>text = ""
for char in tqdm(["a", "b", "c", "d"]):
    text = text + char
</code></pre>

<p><code>trange(i)</code> is a special optimised instance of <code>tqdm(range(i))</code>:</p>

<pre lang="sourceCode"><code>for i in trange(100):
    pass
</code></pre>

<p>Instantiation outside of the loop allows for manual control over
<code>tqdm()</code>:</p>

<pre lang="sourceCode"><code>pbar = tqdm(["a", "b", "c", "d"])
for char in pbar:
    pbar.set_description("Processing %s" % char)
</code></pre>

<h3>
<a id="manual" class="anchor" href="#manual" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Manual</h3>

<p>Manual control on <code>tqdm()</code> updates by using a <code>with</code> statement:</p>

<pre lang="sourceCode"><code>with tqdm(total=100) as pbar:
    for i in range(10):
        pbar.update(10)
</code></pre>

<p>If the optional variable <code>total</code> (or an iterable with <code>len()</code>) is
provided, predictive stats are displayed.</p>

<p><code>with</code> is also optional (you can just assign <code>tqdm()</code> to a variable, but
in this case don't forget to <code>del</code> or <code>close()</code> at the end:</p>

<pre lang="sourceCode"><code>pbar = tqdm(total=100)
for i in range(10):
    pbar.update(10)
pbar.close()
</code></pre>

<h3>
<a id="module" class="anchor" href="#module" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Module</h3>

<p>Perhaps the most wonderful use of <code>tqdm</code> is in a script or on the
command line. Simply inserting <code>tqdm</code> (or <code>python -m tqdm</code>) between
pipes will pass through all <code>stdin</code> to <code>stdout</code> while printing progress
to <code>stderr</code>.</p>

<p>The example below demonstrated counting the number of lines in all
python files in the current directory, with timing information included.</p>

<pre lang="sourceCode"><code>$ time find . -name '*.py' -exec cat \{} \; | wc -l
857365

real    0m3.458s
user    0m0.274s
sys     0m3.325s

$ time find . -name '*.py' -exec cat \{} \; | tqdm | wc -l
857366it [00:03, 246471.31it/s]
857365

real    0m3.585s
user    0m0.862s
sys     0m3.358s
</code></pre>

<p>Note that the usual arguments for <code>tqdm</code> can also be specified.</p>

<pre lang="sourceCode"><code>$ find . -name '*.py' -exec cat \{} \; |
    tqdm --unit loc --unit_scale --total 857366 &gt;&gt; /dev/null
100%|███████████████████████████████████| 857K/857K [00:04&lt;00:00, 246Kloc/s]
</code></pre>

<p>Backing up a large directory?</p>

<pre lang="sourceCode"><code>$ 7z a -bd -r backup.7z docs/ | grep Compressing |
    tqdm --total $(find docs/ -type f | wc -l) --unit files &gt;&gt; backup.log
100%|███████████████████████████████▉| 8014/8014 [01:37&lt;00:00, 82.29files/s]
</code></pre>

<h2>
<a id="help" class="anchor" href="#help" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Help!</h2>

<p>The most common issues relate to excessive output on multiple lines,
instead of a neat one-line progress bar.</p>

<ul>
<li>  Consoles in general: require support for carriage return (<code>CR</code>,
<code>\r</code>).</li>
<li><p>Nested progress bars:
:   -   Consoles in general: require support for moving cursors up
        to the previous line. For example, <a href="https://github.com/tqdm/tqdm/issues/191#issuecomment-230168030">IDLE won't
        work</a>.
    -   Windows: additionally may require the python module
        <code>colorama</code>.</p></li>
<li><p>Wrapping enumerated iterables: use <code>enumerate(tqdm(...))</code> instead of
<code>tqdm(enumerate(...))</code>. The same applies to <code>numpy.ndenumerate</code>.
This is because enumerate functions tend to hide the length of
iterables. <code>tqdm</code> does not.</p></li>
</ul>

<p>If you come across any other difficulties, browse/open issues
<a href="https://github.com/tqdm/tqdm/issues?q=is%3Aissue">here</a>.</p>

<h2>
<a id="documentation" class="anchor" href="#documentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Documentation</h2>

<p><a href="https://pypi.python.org/pypi/tqdm"><img src="https://img.shields.io/pypi/pyversions/tqdm.svg" alt="PyPi-Versions"></a>
<img src="http://hitt.herokuapp.com/tqdm/tqdm.svg" alt="Readme-Hits"> (Since 19 May
2016)</p>

<pre lang="sourceCode"><code>class tqdm(object):
  """
  Decorate an iterable object, returning an iterator which acts exactly
  like the original iterable, but prints a dynamically updating
  progressbar every time a value is requested.
  """

  def __init__(self, iterable=None, desc=None, total=None, leave=True,
               file=sys.stderr, ncols=None, mininterval=0.1,
               maxinterval=10.0, miniters=None, ascii=None, disable=False,
               unit='it', unit_scale=False, dynamic_ncols=False,
               smoothing=0.3, bar_format=None, initial=0, position=None):
</code></pre>

<h3>
<a id="parameters" class="anchor" href="#parameters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parameters</h3>

<ul>
<li><p>iterable : iterable, optional
:   Iterable to decorate with a progressbar. Leave blank to manually
    manage the updates.</p></li>
<li><p>desc : str, optional
:   Prefix for the progressbar.</p></li>
<li><p>total : int, optional
:   The number of expected iterations. If (default: None),
    len(iterable) is used if possible. As a last resort, only basic
    progress statistics are displayed (no ETA, no progressbar). If
    gui is True and this parameter needs subsequent updating,
    specify an initial arbitrary large positive integer, e.g.
    int(9e9).</p></li>
<li><p>leave : bool, optional
:   If [default: True], keeps all traces of the progressbar upon
    termination of iteration.</p></li>
<li><p>file : io.TextIOWrapper or io.StringIO, optional
:   Specifies where to output the progress messages [default:
    sys.stderr]. Uses file.write(str) and file.flush() methods.</p></li>
<li><p>ncols : int, optional
:   The width of the entire output message. If specified,
    dynamically resizes the progressbar to stay within this bound.
    If unspecified, attempts to use environment width. The fallback
    is a meter width of 10 and no limit for the counter and
    statistics. If 0, will not print any meter (only stats).</p></li>
<li><p>mininterval : float, optional
:   Minimum progress update interval, in seconds [default: 0.1].</p></li>
<li><p>maxinterval : float, optional
:   Maximum progress update interval, in seconds [default: 10.0].</p></li>
<li><p>miniters : int, optional
:   Minimum progress update interval, in iterations. If specified,
    will set mininterval to 0.</p></li>
<li><p>ascii : bool, optional
:   If unspecified or False, use unicode (smooth blocks) to fill the
    meter. The fallback is to use ASCII characters 1-9 #.</p></li>
<li><p>disable : bool, optional
:   Whether to disable the entire progressbar wrapper [default:
    False].</p></li>
<li><p>unit : str, optional
:   String that will be used to define the unit of each iteration
    [default: it].</p></li>
<li><p>unit_scale : bool, optional
:   If set, the number of iterations will be reduced/scaled
    automatically and a metric prefix following the International
    System of Units standard will be added (kilo, mega, etc.)
    [default: False].</p></li>
<li><p>dynamic_ncols : bool, optional
:   If set, constantly alters ncols to the environment (allowing for
    window resizes) [default: False].</p></li>
<li><p>smoothing : float, optional
:   Exponential moving average smoothing factor for speed estimates
    (ignored in GUI mode). Ranges from 0 (average speed) to 1
    (current/instantaneous speed) [default: 0.3].</p></li>
<li><p>bar_format : str, optional
:   Specify a custom bar string formatting. May impact performance.
    If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar
    is '{desc}{percentage:3.0f}%|' and r_bar is '|
    {n_fmt}/{total_fmt} [{elapsed_str}&lt;{remaining_str},
    {rate_fmt}]' Possible vars: bar, n, n_fmt, total, total_fmt,
    percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar,
    desc.</p></li>
<li><p>initial : int, optional
:   The initial counter value. Useful when restarting a progress bar
    [default: 0].</p></li>
<li><p>position : int, optional
:   Specify the line offset to print this bar (starting from 0)
    Automatic if unspecified. Useful to manage multiple bars at once
    (eg, from threads).</p></li>
</ul>

<h3>
<a id="extra-cli-options" class="anchor" href="#extra-cli-options" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extra CLI Options</h3>

<ul>
<li><p>delim : chr, optional
:   Delimiting character [default: 'n']. Use '0' for null. N.B.: on
    Windows systems, Python converts 'n' to 'rn'.</p></li>
<li><p>buf_size : int, optional
:   String buffer size in bytes [default: 256] used when delim is
    specified.</p></li>
</ul>

<h3>
<a id="returns" class="anchor" href="#returns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Returns</h3>

<ul>
<li>  out : decorated iterator.</li>
</ul>

<pre lang="sourceCode"><code>def update(self, n=1):
    """
    Manually update the progress bar, useful for streams
    such as reading files.
    E.g.:
    &gt;&gt;&gt; t = tqdm(total=filesize) # Initialise
    &gt;&gt;&gt; for current_buffer in stream:
    ...    ...
    ...    t.update(len(current_buffer))
    &gt;&gt;&gt; t.close()
    The last line is highly recommended, but possibly not necessary if
    `t.update()` will be called in such a way that `filesize` will be
    exactly reached and printed.

    Parameters
    ----------
    n  : int
        Increment to add to the internal counter of iterations
        [default: 1].
    """

def close(self):
    """
    Cleanup and (if leave=False) close the progressbar.
    """

def clear(self):
    """
    Clear current bar display
    """

def refresh(self):
    """
    Force refresh the display of this bar
    """

def write(cls, s, file=sys.stdout, end="\n"):
    """
    Print a message via tqdm (without overlap with bars)
    """
</code></pre>

<blockquote>
<p>def trange(<em>args,kwargs): """ A shortcut for tqdm(xrange(</em>args), **kwargs).
:   On Python3+ range is used instead of xrange. """</p>

<p>class tqdm_gui(tqdm):
:   """ Experimental GUI version of tqdm! """</p>

<p>def tgrange(<em>args,</em>*kwargs):
:   """ Experimental GUI version of trange! """</p>

<p>class tqdm_notebook(tqdm):
:   """ Experimental IPython/Jupyter Notebook widget using tqdm! """</p>

<p>def tnrange(<em>args,</em>*kwargs):
:   """ Experimental IPython/Jupyter Notebook widget using tqdm! """</p>

<h2>
<a id="examples-and-advanced-usage" class="anchor" href="#examples-and-advanced-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples and Advanced Usage</h2>
</blockquote>

<p>See the <a href="https://github.com/tqdm/tqdm/tree/master/examples">examples</a>
folder or import the module and run <code>help()</code>.</p>

<h3>
<a id="nested-progress-bars" class="anchor" href="#nested-progress-bars" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Nested progress bars</h3>

<p><code>tqdm</code> supports nested progress bars. Here's an example:</p>

<pre lang="sourceCode"><code>from tqdm import trange
from time import sleep

for i in trange(10, desc='1st loop'):
    for j in trange(5, desc='2nd loop', leave=False):
        for k in trange(100, desc='3nd loop'):
            sleep(0.01)
</code></pre>

<p>On Windows <a href="https://github.com/tartley/colorama">colorama</a> will be used
if available to produce a beautiful nested display.</p>

<p>For manual control over positioning (e.g. for multi-threaded use), you
may specify position=n where n=0 for the outermost bar, n=1 for the
next, and so on.</p>

<h3>
<a id="hooks-and-callbacks" class="anchor" href="#hooks-and-callbacks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hooks and callbacks</h3>

<p><code>tqdm</code> can easily support callbacks/hooks and manual updates. Here's an
example with <code>urllib</code>:</p>

<p><strong>urllib.urlretrieve documentation</strong></p>

<blockquote>
<p>[...]\
If present, the hook function will be called once\
on establishment of the network connection and once after each block
read\
thereafter. The hook will be passed three arguments; a count of
blocks\
transferred so far, a block size in bytes, and the total size of the
file.\
[...]</p>
</blockquote>

<pre lang="sourceCode"><code>import urllib
from tqdm import tqdm

def my_hook(t):
  """
  Wraps tqdm instance. Don't forget to close() or __exit__()
  the tqdm instance once you're done with it (easiest using `with` syntax).

  Example
  -------

  &gt;&gt;&gt; with tqdm(...) as t:
  ...     reporthook = my_hook(t)
  ...     urllib.urlretrieve(..., reporthook=reporthook)

  """
  last_b = [0]

  def inner(b=1, bsize=1, tsize=None):
    """
    b  : int, optional
        Number of blocks just transferred [default: 1].
    bsize  : int, optional
        Size of each block (in tqdm units) [default: 1].
    tsize  : int, optional
        Total size (in tqdm units). If [default: None] remains unchanged.
    """
    if tsize is not None:
        t.total = tsize
    t.update((b - last_b[0]) * bsize)
    last_b[0] = b
  return inner

eg_link = 'http://www.doc.ic.ac.uk/~cod11/matryoshka.zip'
with tqdm(unit='B', unit_scale=True, miniters=1,
          desc=eg_link.split('/')[-1]) as t:  # all optional kwargs
    urllib.urlretrieve(eg_link, filename='/dev/null',
                       reporthook=my_hook(t), data=None)
</code></pre>

<p>It is recommend to use <code>miniters=1</code> whenever there is potentially large
differences in iteration speed (e.g. downloading a file over a patchy
connection).</p>

<h3>
<a id="pandas-integration" class="anchor" href="#pandas-integration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pandas Integration</h3>

<p>Due to popular demand we've added support for <code>pandas</code> -- here's an
example for <code>DataFrame.progress_apply</code> and
<code>DataFrameGroupBy.progress_apply</code>:</p>

<pre lang="sourceCode"><code>import pandas as pd
import numpy as np
from tqdm import tqdm

...

df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))

# Register `pandas.progress_apply` with `tqdm`
# (can use `tqdm_gui`, `tqdm_notebook`, optional kwargs, etc.)
tqdm.pandas(desc="my bar!")

# Now you can use `progress_apply` instead of `apply`
df.progress_apply(lambda x: x**2)
# can also groupby:
# df.groupby(0).progress_apply(lambda x: x**2)
</code></pre>

<p>In case you're interested in how this works (and how to modify it for
your own callbacks), see the
<a href="https://github.com/tqdm/tqdm/tree/master/examples">examples</a> folder or
import the module and run <code>help()</code>.</p>

<h3>
<a id="ipythonjupyter-integration" class="anchor" href="#ipythonjupyter-integration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IPython/Jupyter Integration</h3>

<p>IPython/Jupyter is supported via the tqdm_notebook submodule:</p>

<pre lang="sourceCode"><code>from tqdm import tnrange, tqdm_notebook
from time import sleep

for i in tnrange(10, desc='1st loop'):
    for j in tqdm_notebook(xrange(100), desc='2nd loop'):
        sleep(0.01)
</code></pre>

<p>In addition to tqdm features, the submodule provides a native Jupyter
widget (compatible with IPython v1-v4 and Jupyter), fully working nested
bars and color hints (blue: normal, green: completed, red:
error/interrupt, light blue: no ETA); as demonstrated below.</p>

<p><img src="https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-1.gif" alt="Screenshot-Jupyter1">
<img src="https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-2.gif" alt="Screenshot-Jupyter2">
<img src="https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-3.gif" alt="Screenshot-Jupyter3"></p>

<h3>
<a id="writing-messages" class="anchor" href="#writing-messages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing messages</h3>

<p>Since <code>tqdm</code> uses a simple printing mechanism to display progress bars,
you should not write any message in the terminal using <code>print()</code>.</p>

<p>To write messages in the terminal without any collision with <code>tqdm</code> bar
display, a <code>.write()</code> method is provided:</p>

<pre lang="sourceCode"><code>from tqdm import tqdm, trange
from time import sleep

bar = trange(10)
for i in bar:
    # Print using tqdm class method .write()
    sleep(0.1)
    if not (i % 3):
        tqdm.write("Done task %i" % i)
    # Can also use bar.write()
</code></pre>

<p>By default, this will print to standard output <code>sys.stdout</code>. but you can
specify any file-like object using the <code>file</code> argument. For example,
this can be used to redirect the messages writing to a log file or
class.</p>

<h3>
<a id="redirecting-writing" class="anchor" href="#redirecting-writing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Redirecting writing</h3>

<p>If using a library that can print messages to the console, editing the
library by replacing <code>print()</code> with <code>tqdm.write()</code> may not be desirable.
In that case, redirecting <code>sys.stdout</code> to <code>tqdm.write()</code> is an option.</p>

<p>To redirect <code>sys.stdout</code>, create a file-like class that will write any
input string to <code>tqdm.write()</code>, and supply the arguments
<code>file=sys.stdout, dynamic_ncols=True</code>.</p>

<p>A reusable canonical example is given below:</p>

<pre lang="sourceCode"><code>from time import sleep

import contextlib
import sys

from tqdm import tqdm

class DummyTqdmFile(object):
    """Dummy file-like that will write to tqdm"""
    file = None
    def __init__(self, file):
        self.file = file

    def write(self, x):
        # Avoid print() second call (useless \n)
        if len(x.rstrip()) &gt; 0:
            tqdm.write(x, file=self.file)

@contextlib.contextmanager
def stdout_redirect_to_tqdm():
    save_stdout = sys.stdout
    try:
        sys.stdout = DummyTqdmFile(sys.stdout)
        yield save_stdout
    # Relay exceptions
    except Exception as exc:
        raise exc
    # Always restore sys.stdout if necessary
    finally:
        sys.stdout = save_stdout

def blabla():
    print("Foo blabla")

# Redirect stdout to tqdm.write() (don't forget the `as save_stdout`)
with stdout_redirect_to_tqdm() as save_stdout:
    # tqdm call need to specify sys.stdout, not sys.stderr (default)
    # and dynamic_ncols=True to autodetect console width
    for _ in tqdm(range(3), file=save_stdout, dynamic_ncols=True):
        blabla()
        sleep(.5)

# After the `with`, printing is restored
print('Done!')
</code></pre>

<h3>
<a id="how-to-make-a-good-progress-bar" class="anchor" href="#how-to-make-a-good-progress-bar" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How to make a good progress bar</h3>

<p>A good progress bar is a useful progress bar. To be useful, <code>tqdm</code>
displays statistics and uses smart algorithms to predict and
automagically adapt to a variety of use cases with no or minimal
configuration.</p>

<p>However, there is one thing that <code>tqdm</code> cannot do: choose a pertinent
progress indicator. To display a useful progress bar, it is very
important that <code>tqdm</code> is supplied with the most pertinent progress
indicator. This will reflect most accurately the current state of your
program. Usually, a good way is to preprocess quickly to first evaluate
the total amount of work to do before beginning the real processing.</p>

<p>To illustrate the importance of a good progress indicator, take the
following example: you want to walk through all files of a directory and
process their contents with some external function:</p>

<pre lang="sourceCode"><code>import os
from tqdm import tqdm, trange
from time import sleep

def dosomething(buf):
    """Do something with the content of a file"""
    sleep(0.01)
    pass

def walkdir(folder):
    """Walk through each files in a directory"""
    for dirpath, dirs, files in os.walk(folder):
        for filename in files:
            yield os.path.abspath(os.path.join(dirpath, filename))

def process_content_no_progress(inputpath, blocksize=1024):
    for filepath in walkdir(inputpath):
        with open(filepath, 'rb') as fh:
            buf = 1
            while (buf):
                buf = fh.read(blocksize)
                dosomething(buf)
</code></pre>

<p><code>process_content_no_progress()</code> does the job, but does not show any
information about the current progress, nor how long it will take.</p>

<p>To quickly fix that using <code>tqdm</code>, we can use this naive approach:</p>

<pre lang="sourceCode"><code>def process_content_with_progress1(inputpath, blocksize=1024):
    for filepath in tqdm(walkdir(inputpath)):
        with open(filepath, 'rb') as fh:
            buf = 1
            while (buf):
                buf = fh.read(blocksize)
                dosomething(buf)
</code></pre>

<p><code>process_content_with_progress1()</code> will load <code>tqdm()</code>, but since the
iterator does not provide any length (<code>os.walkdir()</code> does not have a
<code>__len__()</code> method for the total files count), there is only an
indication of the current and past program state, no prediction:</p>

<p><code>4it [00:03,  2.79it/s]</code></p>

<p>The way to get predictive information is to know the total amount of
work to be done. Since <code>os.walkdir()</code> cannot give us this information,
we need to precompute this by ourselves:</p>

<pre lang="sourceCode"><code>def process_content_with_progress2(inputpath, blocksize=1024):
    # Preprocess the total files count
    filecounter = 0
    for dirpath, dirs, files in tqdm(os.walk(inputpath)):
        for filename in files:
            filecounter += 1

    for filepath in tqdm(walkdir(inputpath), total=filecounter):
        with open(filepath, 'rb') as fh:
            buf = 1
            while (buf):
                buf = fh.read(blocksize)
                dosomething(buf)
</code></pre>

<p><code>process_content_with_progress2()</code> is better than the naive approach
because now we have predictive information:</p>

<p><code>50%|████████████            | 2/4 [00:00&lt;00:00,  4.06it/s]</code></p>

<p>However, the progress is not smooth: it increments in steps, 1 step
being 1 file processed. The problem is that we do not just walk through
files tree, but we process the files contents. Thus, if we stumble on
one very large file which takes a great deal more time to process than
other smaller files, the progress bar will still considers that file is
of equal processing weight.</p>

<p>To fix this, we should use another indicator than the files count: the
total sum of all files sizes. This would be more pertinent since the
data we process is the files' content, so there is a direct relation
between size and content.</p>

<p>Below we implement this approach using a manually updated <code>tqdm</code> bar,
where <code>tqdm</code> will work on size, while the <code>for</code> loop works on files
paths:</p>

<pre lang="sourceCode"><code>def process_content_with_progress3(inputpath, blocksize=1024):
    # Preprocess the total files sizes
    sizecounter = 0
    for dirpath, dirs, files in tqdm(os.walk(inputpath)):
        for filename in files:
            fullpath = os.path.abspath(os.path.join(dirpath, filename))
            sizecounter += os.stat(fullpath).st_size

    # Load tqdm with size counter instead of files counter
    with tqdm(total=sizecounter, unit='B', unit_scale=True) as pbar:
        for dirpath, dirs, files in os.walk(inputpath):
            for filename in files:
                fullpath = os.path.abspath(os.path.join(dirpath, filename))
                with open(fullpath, 'rb') as fh:
                    buf = 1
                    while (buf):
                        buf = fh.read(blocksize)
                        dosomething(buf)
                        if buf: pbar.update(len(buf))
</code></pre>

<p>And here is the result: a much smoother progress bar with meaningful
predicted time and statistics:</p>

<p><code>47%|████████████             | 152K/321K [00:03&lt;00:03, 46.2KB/s]</code></p>

<h2>
<a id="contributions" class="anchor" href="#contributions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributions</h2>

<p>All source code is hosted on <a href="https://github.com/tqdm/tqdm">github</a>.
Contributions are welcome.</p>

<p>See the
<a href="https://raw.githubusercontent.com/tqdm/tqdm/master/CONTRIBUTE">CONTRIBUTE</a>
file for more information.</p>

<h2>
<a id="licence" class="anchor" href="#licence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Licence</h2>

<p>Open Source (OSI approved):
<a href="https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE"><img src="https://img.shields.io/pypi/l/tqdm.svg" alt="Licence"></a></p>

<p>Citation information:
<a href="https://zenodo.org/badge/latestdoi/21637/tqdm/tqdm"><img src="https://zenodo.org/badge/21637/tqdm/tqdm.svg" alt="DOI-URI"></a></p>

<h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors</h2>

<p>Ranked by contributions.</p>

<ul>
<li>  Casper da Costa-Luis (casperdcl)</li>
<li>  Stephen Larroque (lrq3000)</li>
<li>  Hadrien Mary (hadim)</li>
<li>  Noam Yorav-Raphael (noamraph)*</li>
<li>  Ivan Ivanov (obiwanus)</li>
<li>  Mikhail Korobov (kmike)</li>
</ul>

<p>* Original author</p>

<p><img src="http://hitt.herokuapp.com/tqdm/tqdm.svg" alt="Readme-Hits"> (Since 19 May
2016)</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
