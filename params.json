{
  "name": "tqdm",
  "tagline": "minimal overhead highly customisable progress bar",
  "body": "![Logo](https://raw.githubusercontent.com/tqdm/tqdm/master/logo.png)\r\n\r\ntqdm\r\n====\r\n\r\n[![PyPi-Status](https://img.shields.io/pypi/v/tqdm.svg)](https://pypi.python.org/pypi/tqdm)\r\n[![PyPi-Versions](https://img.shields.io/pypi/pyversions/tqdm.svg)](https://pypi.python.org/pypi/tqdm)\r\n\r\n[![Build-Status](https://travis-ci.org/tqdm/tqdm.svg?branch=master)](https://travis-ci.org/tqdm/tqdm)\r\n[![Coverage-Status](https://coveralls.io/repos/tqdm/tqdm/badge.svg)](https://coveralls.io/r/tqdm/tqdm)\r\n[![Branch-Coverage-Status](https://codecov.io/github/tqdm/tqdm/coverage.svg?branch=master)](https://codecov.io/github/tqdm/tqdm?branch=master)\r\n\r\n[![DOI-URI](https://zenodo.org/badge/21637/tqdm/tqdm.svg)](https://zenodo.org/badge/latestdoi/21637/tqdm/tqdm)\r\n[![Licence](https://img.shields.io/pypi/l/tqdm.svg)](https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE)\r\n\r\n`tqdm` (read taqadum, تقدّم) means \"progress\" in arabic.\r\n\r\nInstantly make your loops show a smart progress meter - just wrap any\r\niterable with \"tqdm(iterable)\", and you're done!\r\n\r\n~~~~ {.sourceCode .python}\r\nfrom tqdm import tqdm\r\nfor i in tqdm(range(9)):\r\n    ...\r\n~~~~\r\n\r\nHere's what the output looks like:\r\n\r\n`76%|████████████████████████████         | 7568/10000 [00:33<00:10, 229.00it/s]`\r\n\r\n`trange(N)` can be also used as a convenient shortcut for\r\n`tqdm(xrange(N))`.\r\n\r\n![Screenshot](https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm.gif)\r\n\r\nIt can also be executed as a module with pipes:\r\n\r\n~~~~ {.sourceCode .sh}\r\n$ seq 9999999 | tqdm --unit_scale | wc -l\r\n10.0Mit [00:02, 3.58Mit/s]\r\n9999999\r\n~~~~\r\n\r\nOverhead is low -- about 60ns per iteration (80ns with `tqdm_gui`), and\r\nis unit tested against performance regression. By comparison, the well\r\nestablished\r\n[ProgressBar](https://github.com/niltonvolpato/python-progressbar) has\r\nan 800ns/iter overhead.\r\n\r\nIn addition to its low overhead, `tqdm` uses smart algorithms to predict\r\nthe remaining time and to skip unnecessary iteration displays, which\r\nallows for a negligible overhead in most cases.\r\n\r\n`tqdm` works on any platform (Linux, Windows, Mac, FreeBSD,\r\nSolaris/SunOS), in any console or in a GUI, and is also friendly with\r\nIPython/Jupyter notebooks.\r\n\r\n`tqdm` does not require any library (not even curses!) to run, just a\r\nvanilla Python interpreter will do and an environment supporting\r\n`carriage return \\r` and `line feed \\n` control characters.\r\n\r\n* * * * *\r\n\r\nInstallation\r\n------------\r\n\r\n### Latest pypi stable release\r\n\r\n[![PyPi-Status](https://img.shields.io/pypi/v/tqdm.svg)](https://pypi.python.org/pypi/tqdm)\r\n\r\n~~~~ {.sourceCode .sh}\r\npip install tqdm\r\n~~~~\r\n\r\n### Latest development release on github\r\n\r\n[![Github-Status](https://img.shields.io/github/tag/tqdm/tqdm.svg?maxAge=2592000)](https://github.com/tqdm/tqdm/releases)\r\n[![Github-Stars](https://img.shields.io/github/stars/tqdm/tqdm.svg)](https://github.com/tqdm/tqdm/stargazers)\r\n[![Github-Forks](https://img.shields.io/github/forks/tqdm/tqdm.svg)](https://github.com/tqdm/tqdm/network)\r\n\r\nPull and install in the current directory:\r\n\r\n~~~~ {.sourceCode .sh}\r\npip install -e git+https://github.com/tqdm/tqdm.git@master#egg=tqdm\r\n~~~~\r\n\r\nChangelog\r\n---------\r\n\r\nThe list of all changes is available either on Github's Releases:\r\n[![Github-Status](https://img.shields.io/github/tag/tqdm/tqdm.svg?maxAge=2592000)](https://github.com/tqdm/tqdm/releases)\r\nor on crawlers such as\r\n[allmychanges.com](https://allmychanges.com/p/python/tqdm/).\r\n\r\nUsage\r\n-----\r\n\r\n`tqdm` is very versatile and can be used in a number of ways. The three\r\nmain ones are given below.\r\n\r\n### Iterable-based\r\n\r\nWrap `tqdm()` around any iterable:\r\n\r\n~~~~ {.sourceCode .python}\r\ntext = \"\"\r\nfor char in tqdm([\"a\", \"b\", \"c\", \"d\"]):\r\n    text = text + char\r\n~~~~\r\n\r\n`trange(i)` is a special optimised instance of `tqdm(range(i))`:\r\n\r\n~~~~ {.sourceCode .python}\r\nfor i in trange(100):\r\n    pass\r\n~~~~\r\n\r\nInstantiation outside of the loop allows for manual control over\r\n`tqdm()`:\r\n\r\n~~~~ {.sourceCode .python}\r\npbar = tqdm([\"a\", \"b\", \"c\", \"d\"])\r\nfor char in pbar:\r\n    pbar.set_description(\"Processing %s\" % char)\r\n~~~~\r\n\r\n### Manual\r\n\r\nManual control on `tqdm()` updates by using a `with` statement:\r\n\r\n~~~~ {.sourceCode .python}\r\nwith tqdm(total=100) as pbar:\r\n    for i in range(10):\r\n        pbar.update(10)\r\n~~~~\r\n\r\nIf the optional variable `total` (or an iterable with `len()`) is\r\nprovided, predictive stats are displayed.\r\n\r\n`with` is also optional (you can just assign `tqdm()` to a variable, but\r\nin this case don't forget to `del` or `close()` at the end:\r\n\r\n~~~~ {.sourceCode .python}\r\npbar = tqdm(total=100)\r\nfor i in range(10):\r\n    pbar.update(10)\r\npbar.close()\r\n~~~~\r\n\r\n### Module\r\n\r\nPerhaps the most wonderful use of `tqdm` is in a script or on the\r\ncommand line. Simply inserting `tqdm` (or `python -m tqdm`) between\r\npipes will pass through all `stdin` to `stdout` while printing progress\r\nto `stderr`.\r\n\r\nThe example below demonstrated counting the number of lines in all\r\npython files in the current directory, with timing information included.\r\n\r\n~~~~ {.sourceCode .sh}\r\n$ time find . -name '*.py' -exec cat \\{} \\; | wc -l\r\n857365\r\n\r\nreal    0m3.458s\r\nuser    0m0.274s\r\nsys     0m3.325s\r\n\r\n$ time find . -name '*.py' -exec cat \\{} \\; | tqdm | wc -l\r\n857366it [00:03, 246471.31it/s]\r\n857365\r\n\r\nreal    0m3.585s\r\nuser    0m0.862s\r\nsys     0m3.358s\r\n~~~~\r\n\r\nNote that the usual arguments for `tqdm` can also be specified.\r\n\r\n~~~~ {.sourceCode .sh}\r\n$ find . -name '*.py' -exec cat \\{} \\; |\r\n    tqdm --unit loc --unit_scale --total 857366 >> /dev/null\r\n100%|███████████████████████████████████| 857K/857K [00:04<00:00, 246Kloc/s]\r\n~~~~\r\n\r\nBacking up a large directory?\r\n\r\n~~~~ {.sourceCode .sh}\r\n$ 7z a -bd -r backup.7z docs/ | grep Compressing |\r\n    tqdm --total $(find docs/ -type f | wc -l) --unit files >> backup.log\r\n100%|███████████████████████████████▉| 8014/8014 [01:37<00:00, 82.29files/s]\r\n~~~~\r\n\r\nHelp!\r\n-----\r\n\r\nThe most common issues relate to excessive output on multiple lines,\r\ninstead of a neat one-line progress bar.\r\n\r\n-   Consoles in general: require support for carriage return (`CR`,\r\n    `\\r`).\r\n-   Nested progress bars:\r\n    :   -   Consoles in general: require support for moving cursors up\r\n            to the previous line. For example, [IDLE won't\r\n            work](https://github.com/tqdm/tqdm/issues/191#issuecomment-230168030).\r\n        -   Windows: additionally may require the python module\r\n            `colorama`.\r\n\r\n-   Wrapping enumerated iterables: use `enumerate(tqdm(...))` instead of\r\n    `tqdm(enumerate(...))`. The same applies to `numpy.ndenumerate`.\r\n    This is because enumerate functions tend to hide the length of\r\n    iterables. `tqdm` does not.\r\n\r\nIf you come across any other difficulties, browse/open issues\r\n[here](https://github.com/tqdm/tqdm/issues?q=is%3Aissue).\r\n\r\nDocumentation\r\n-------------\r\n\r\n[![PyPi-Versions](https://img.shields.io/pypi/pyversions/tqdm.svg)](https://pypi.python.org/pypi/tqdm)\r\n![Readme-Hits](http://hitt.herokuapp.com/tqdm/tqdm.svg) (Since 19 May\r\n2016)\r\n\r\n~~~~ {.sourceCode .python}\r\nclass tqdm(object):\r\n  \"\"\"\r\n  Decorate an iterable object, returning an iterator which acts exactly\r\n  like the original iterable, but prints a dynamically updating\r\n  progressbar every time a value is requested.\r\n  \"\"\"\r\n\r\n  def __init__(self, iterable=None, desc=None, total=None, leave=True,\r\n               file=sys.stderr, ncols=None, mininterval=0.1,\r\n               maxinterval=10.0, miniters=None, ascii=None, disable=False,\r\n               unit='it', unit_scale=False, dynamic_ncols=False,\r\n               smoothing=0.3, bar_format=None, initial=0, position=None):\r\n~~~~\r\n\r\n### Parameters\r\n\r\n-   iterable : iterable, optional\r\n    :   Iterable to decorate with a progressbar. Leave blank to manually\r\n        manage the updates.\r\n\r\n-   desc : str, optional\r\n    :   Prefix for the progressbar.\r\n\r\n-   total : int, optional\r\n    :   The number of expected iterations. If (default: None),\r\n        len(iterable) is used if possible. As a last resort, only basic\r\n        progress statistics are displayed (no ETA, no progressbar). If\r\n        gui is True and this parameter needs subsequent updating,\r\n        specify an initial arbitrary large positive integer, e.g.\r\n        int(9e9).\r\n\r\n-   leave : bool, optional\r\n    :   If [default: True], keeps all traces of the progressbar upon\r\n        termination of iteration.\r\n\r\n-   file : io.TextIOWrapper or io.StringIO, optional\r\n    :   Specifies where to output the progress messages [default:\r\n        sys.stderr]. Uses file.write(str) and file.flush() methods.\r\n\r\n-   ncols : int, optional\r\n    :   The width of the entire output message. If specified,\r\n        dynamically resizes the progressbar to stay within this bound.\r\n        If unspecified, attempts to use environment width. The fallback\r\n        is a meter width of 10 and no limit for the counter and\r\n        statistics. If 0, will not print any meter (only stats).\r\n\r\n-   mininterval : float, optional\r\n    :   Minimum progress update interval, in seconds [default: 0.1].\r\n\r\n-   maxinterval : float, optional\r\n    :   Maximum progress update interval, in seconds [default: 10.0].\r\n\r\n-   miniters : int, optional\r\n    :   Minimum progress update interval, in iterations. If specified,\r\n        will set mininterval to 0.\r\n\r\n-   ascii : bool, optional\r\n    :   If unspecified or False, use unicode (smooth blocks) to fill the\r\n        meter. The fallback is to use ASCII characters 1-9 \\#.\r\n\r\n-   disable : bool, optional\r\n    :   Whether to disable the entire progressbar wrapper [default:\r\n        False].\r\n\r\n-   unit : str, optional\r\n    :   String that will be used to define the unit of each iteration\r\n        [default: it].\r\n\r\n-   unit\\_scale : bool, optional\r\n    :   If set, the number of iterations will be reduced/scaled\r\n        automatically and a metric prefix following the International\r\n        System of Units standard will be added (kilo, mega, etc.)\r\n        [default: False].\r\n\r\n-   dynamic\\_ncols : bool, optional\r\n    :   If set, constantly alters ncols to the environment (allowing for\r\n        window resizes) [default: False].\r\n\r\n-   smoothing : float, optional\r\n    :   Exponential moving average smoothing factor for speed estimates\r\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\r\n        (current/instantaneous speed) [default: 0.3].\r\n\r\n-   bar\\_format : str, optional\r\n    :   Specify a custom bar string formatting. May impact performance.\r\n        If unspecified, will use '{l\\_bar}{bar}{r\\_bar}', where l\\_bar\r\n        is '{desc}{percentage:3.0f}%|' and r\\_bar is '|\r\n        {n\\_fmt}/{total\\_fmt} [{elapsed\\_str}\\<{remaining\\_str},\r\n        {rate\\_fmt}]' Possible vars: bar, n, n\\_fmt, total, total\\_fmt,\r\n        percentage, rate, rate\\_fmt, elapsed, remaining, l\\_bar, r\\_bar,\r\n        desc.\r\n\r\n-   initial : int, optional\r\n    :   The initial counter value. Useful when restarting a progress bar\r\n        [default: 0].\r\n\r\n-   position : int, optional\r\n    :   Specify the line offset to print this bar (starting from 0)\r\n        Automatic if unspecified. Useful to manage multiple bars at once\r\n        (eg, from threads).\r\n\r\n### Extra CLI Options\r\n\r\n-   delim : chr, optional\r\n    :   Delimiting character [default: 'n']. Use '0' for null. N.B.: on\r\n        Windows systems, Python converts 'n' to 'rn'.\r\n\r\n-   buf\\_size : int, optional\r\n    :   String buffer size in bytes [default: 256] used when delim is\r\n        specified.\r\n\r\n### Returns\r\n\r\n-   out : decorated iterator.\r\n\r\n~~~~ {.sourceCode .python}\r\ndef update(self, n=1):\r\n    \"\"\"\r\n    Manually update the progress bar, useful for streams\r\n    such as reading files.\r\n    E.g.:\r\n    >>> t = tqdm(total=filesize) # Initialise\r\n    >>> for current_buffer in stream:\r\n    ...    ...\r\n    ...    t.update(len(current_buffer))\r\n    >>> t.close()\r\n    The last line is highly recommended, but possibly not necessary if\r\n    `t.update()` will be called in such a way that `filesize` will be\r\n    exactly reached and printed.\r\n\r\n    Parameters\r\n    ----------\r\n    n  : int\r\n        Increment to add to the internal counter of iterations\r\n        [default: 1].\r\n    \"\"\"\r\n\r\ndef close(self):\r\n    \"\"\"\r\n    Cleanup and (if leave=False) close the progressbar.\r\n    \"\"\"\r\n\r\ndef clear(self):\r\n    \"\"\"\r\n    Clear current bar display\r\n    \"\"\"\r\n\r\ndef refresh(self):\r\n    \"\"\"\r\n    Force refresh the display of this bar\r\n    \"\"\"\r\n\r\ndef write(cls, s, file=sys.stdout, end=\"\\n\"):\r\n    \"\"\"\r\n    Print a message via tqdm (without overlap with bars)\r\n    \"\"\"\r\n~~~~\r\n\r\n> def trange(*args,kwargs): \"\"\" A shortcut for tqdm(xrange(*args), \\*\\*kwargs).\r\n> :   On Python3+ range is used instead of xrange. \"\"\"\r\n>\r\n> class tqdm\\_gui(tqdm):\r\n> :   \"\"\" Experimental GUI version of tqdm! \"\"\"\r\n>\r\n> def tgrange(*args,*\\*kwargs):\r\n> :   \"\"\" Experimental GUI version of trange! \"\"\"\r\n>\r\n> class tqdm\\_notebook(tqdm):\r\n> :   \"\"\" Experimental IPython/Jupyter Notebook widget using tqdm! \"\"\"\r\n>\r\n> def tnrange(*args,*\\*kwargs):\r\n> :   \"\"\" Experimental IPython/Jupyter Notebook widget using tqdm! \"\"\"\r\n>\r\nExamples and Advanced Usage\r\n---------------------------\r\n\r\nSee the [examples](https://github.com/tqdm/tqdm/tree/master/examples)\r\nfolder or import the module and run `help()`.\r\n\r\n### Nested progress bars\r\n\r\n`tqdm` supports nested progress bars. Here's an example:\r\n\r\n~~~~ {.sourceCode .python}\r\nfrom tqdm import trange\r\nfrom time import sleep\r\n\r\nfor i in trange(10, desc='1st loop'):\r\n    for j in trange(5, desc='2nd loop', leave=False):\r\n        for k in trange(100, desc='3nd loop'):\r\n            sleep(0.01)\r\n~~~~\r\n\r\nOn Windows [colorama](https://github.com/tartley/colorama) will be used\r\nif available to produce a beautiful nested display.\r\n\r\nFor manual control over positioning (e.g. for multi-threaded use), you\r\nmay specify position=n where n=0 for the outermost bar, n=1 for the\r\nnext, and so on.\r\n\r\n### Hooks and callbacks\r\n\r\n`tqdm` can easily support callbacks/hooks and manual updates. Here's an\r\nexample with `urllib`:\r\n\r\n**urllib.urlretrieve documentation**\r\n\r\n> [...]\\\r\n> If present, the hook function will be called once\\\r\n> on establishment of the network connection and once after each block\r\n> read\\\r\n> thereafter. The hook will be passed three arguments; a count of\r\n> blocks\\\r\n> transferred so far, a block size in bytes, and the total size of the\r\n> file.\\\r\n> [...]\r\n\r\n~~~~ {.sourceCode .python}\r\nimport urllib\r\nfrom tqdm import tqdm\r\n\r\ndef my_hook(t):\r\n  \"\"\"\r\n  Wraps tqdm instance. Don't forget to close() or __exit__()\r\n  the tqdm instance once you're done with it (easiest using `with` syntax).\r\n\r\n  Example\r\n  -------\r\n\r\n  >>> with tqdm(...) as t:\r\n  ...     reporthook = my_hook(t)\r\n  ...     urllib.urlretrieve(..., reporthook=reporthook)\r\n\r\n  \"\"\"\r\n  last_b = [0]\r\n\r\n  def inner(b=1, bsize=1, tsize=None):\r\n    \"\"\"\r\n    b  : int, optional\r\n        Number of blocks just transferred [default: 1].\r\n    bsize  : int, optional\r\n        Size of each block (in tqdm units) [default: 1].\r\n    tsize  : int, optional\r\n        Total size (in tqdm units). If [default: None] remains unchanged.\r\n    \"\"\"\r\n    if tsize is not None:\r\n        t.total = tsize\r\n    t.update((b - last_b[0]) * bsize)\r\n    last_b[0] = b\r\n  return inner\r\n\r\neg_link = 'http://www.doc.ic.ac.uk/~cod11/matryoshka.zip'\r\nwith tqdm(unit='B', unit_scale=True, miniters=1,\r\n          desc=eg_link.split('/')[-1]) as t:  # all optional kwargs\r\n    urllib.urlretrieve(eg_link, filename='/dev/null',\r\n                       reporthook=my_hook(t), data=None)\r\n~~~~\r\n\r\nIt is recommend to use `miniters=1` whenever there is potentially large\r\ndifferences in iteration speed (e.g. downloading a file over a patchy\r\nconnection).\r\n\r\n### Pandas Integration\r\n\r\nDue to popular demand we've added support for `pandas` -- here's an\r\nexample for `DataFrame.progress_apply` and\r\n`DataFrameGroupBy.progress_apply`:\r\n\r\n~~~~ {.sourceCode .python}\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom tqdm import tqdm\r\n\r\n...\r\n\r\ndf = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\r\n\r\n# Register `pandas.progress_apply` with `tqdm`\r\n# (can use `tqdm_gui`, `tqdm_notebook`, optional kwargs, etc.)\r\ntqdm.pandas(desc=\"my bar!\")\r\n\r\n# Now you can use `progress_apply` instead of `apply`\r\ndf.progress_apply(lambda x: x**2)\r\n# can also groupby:\r\n# df.groupby(0).progress_apply(lambda x: x**2)\r\n~~~~\r\n\r\nIn case you're interested in how this works (and how to modify it for\r\nyour own callbacks), see the\r\n[examples](https://github.com/tqdm/tqdm/tree/master/examples) folder or\r\nimport the module and run `help()`.\r\n\r\n### IPython/Jupyter Integration\r\n\r\nIPython/Jupyter is supported via the tqdm\\_notebook submodule:\r\n\r\n~~~~ {.sourceCode .python}\r\nfrom tqdm import tnrange, tqdm_notebook\r\nfrom time import sleep\r\n\r\nfor i in tnrange(10, desc='1st loop'):\r\n    for j in tqdm_notebook(xrange(100), desc='2nd loop'):\r\n        sleep(0.01)\r\n~~~~\r\n\r\nIn addition to tqdm features, the submodule provides a native Jupyter\r\nwidget (compatible with IPython v1-v4 and Jupyter), fully working nested\r\nbars and color hints (blue: normal, green: completed, red:\r\nerror/interrupt, light blue: no ETA); as demonstrated below.\r\n\r\n![Screenshot-Jupyter1](https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-1.gif)\r\n![Screenshot-Jupyter2](https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-2.gif)\r\n![Screenshot-Jupyter3](https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm-jupyter-3.gif)\r\n\r\n### Writing messages\r\n\r\nSince `tqdm` uses a simple printing mechanism to display progress bars,\r\nyou should not write any message in the terminal using `print()`.\r\n\r\nTo write messages in the terminal without any collision with `tqdm` bar\r\ndisplay, a `.write()` method is provided:\r\n\r\n~~~~ {.sourceCode .python}\r\nfrom tqdm import tqdm, trange\r\nfrom time import sleep\r\n\r\nbar = trange(10)\r\nfor i in bar:\r\n    # Print using tqdm class method .write()\r\n    sleep(0.1)\r\n    if not (i % 3):\r\n        tqdm.write(\"Done task %i\" % i)\r\n    # Can also use bar.write()\r\n~~~~\r\n\r\nBy default, this will print to standard output `sys.stdout`. but you can\r\nspecify any file-like object using the `file` argument. For example,\r\nthis can be used to redirect the messages writing to a log file or\r\nclass.\r\n\r\n### Redirecting writing\r\n\r\nIf using a library that can print messages to the console, editing the\r\nlibrary by replacing `print()` with `tqdm.write()` may not be desirable.\r\nIn that case, redirecting `sys.stdout` to `tqdm.write()` is an option.\r\n\r\nTo redirect `sys.stdout`, create a file-like class that will write any\r\ninput string to `tqdm.write()`, and supply the arguments\r\n`file=sys.stdout, dynamic_ncols=True`.\r\n\r\nA reusable canonical example is given below:\r\n\r\n~~~~ {.sourceCode .python}\r\nfrom time import sleep\r\n\r\nimport contextlib\r\nimport sys\r\n\r\nfrom tqdm import tqdm\r\n\r\nclass DummyTqdmFile(object):\r\n    \"\"\"Dummy file-like that will write to tqdm\"\"\"\r\n    file = None\r\n    def __init__(self, file):\r\n        self.file = file\r\n\r\n    def write(self, x):\r\n        # Avoid print() second call (useless \\n)\r\n        if len(x.rstrip()) > 0:\r\n            tqdm.write(x, file=self.file)\r\n\r\n@contextlib.contextmanager\r\ndef stdout_redirect_to_tqdm():\r\n    save_stdout = sys.stdout\r\n    try:\r\n        sys.stdout = DummyTqdmFile(sys.stdout)\r\n        yield save_stdout\r\n    # Relay exceptions\r\n    except Exception as exc:\r\n        raise exc\r\n    # Always restore sys.stdout if necessary\r\n    finally:\r\n        sys.stdout = save_stdout\r\n\r\ndef blabla():\r\n    print(\"Foo blabla\")\r\n\r\n# Redirect stdout to tqdm.write() (don't forget the `as save_stdout`)\r\nwith stdout_redirect_to_tqdm() as save_stdout:\r\n    # tqdm call need to specify sys.stdout, not sys.stderr (default)\r\n    # and dynamic_ncols=True to autodetect console width\r\n    for _ in tqdm(range(3), file=save_stdout, dynamic_ncols=True):\r\n        blabla()\r\n        sleep(.5)\r\n\r\n# After the `with`, printing is restored\r\nprint('Done!')\r\n~~~~\r\n\r\n### How to make a good progress bar\r\n\r\nA good progress bar is a useful progress bar. To be useful, `tqdm`\r\ndisplays statistics and uses smart algorithms to predict and\r\nautomagically adapt to a variety of use cases with no or minimal\r\nconfiguration.\r\n\r\nHowever, there is one thing that `tqdm` cannot do: choose a pertinent\r\nprogress indicator. To display a useful progress bar, it is very\r\nimportant that `tqdm` is supplied with the most pertinent progress\r\nindicator. This will reflect most accurately the current state of your\r\nprogram. Usually, a good way is to preprocess quickly to first evaluate\r\nthe total amount of work to do before beginning the real processing.\r\n\r\nTo illustrate the importance of a good progress indicator, take the\r\nfollowing example: you want to walk through all files of a directory and\r\nprocess their contents with some external function:\r\n\r\n~~~~ {.sourceCode .python}\r\nimport os\r\nfrom tqdm import tqdm, trange\r\nfrom time import sleep\r\n\r\ndef dosomething(buf):\r\n    \"\"\"Do something with the content of a file\"\"\"\r\n    sleep(0.01)\r\n    pass\r\n\r\ndef walkdir(folder):\r\n    \"\"\"Walk through each files in a directory\"\"\"\r\n    for dirpath, dirs, files in os.walk(folder):\r\n        for filename in files:\r\n            yield os.path.abspath(os.path.join(dirpath, filename))\r\n\r\ndef process_content_no_progress(inputpath, blocksize=1024):\r\n    for filepath in walkdir(inputpath):\r\n        with open(filepath, 'rb') as fh:\r\n            buf = 1\r\n            while (buf):\r\n                buf = fh.read(blocksize)\r\n                dosomething(buf)\r\n~~~~\r\n\r\n`process_content_no_progress()` does the job, but does not show any\r\ninformation about the current progress, nor how long it will take.\r\n\r\nTo quickly fix that using `tqdm`, we can use this naive approach:\r\n\r\n~~~~ {.sourceCode .python}\r\ndef process_content_with_progress1(inputpath, blocksize=1024):\r\n    for filepath in tqdm(walkdir(inputpath)):\r\n        with open(filepath, 'rb') as fh:\r\n            buf = 1\r\n            while (buf):\r\n                buf = fh.read(blocksize)\r\n                dosomething(buf)\r\n~~~~\r\n\r\n`process_content_with_progress1()` will load `tqdm()`, but since the\r\niterator does not provide any length (`os.walkdir()` does not have a\r\n`__len__()` method for the total files count), there is only an\r\nindication of the current and past program state, no prediction:\r\n\r\n`4it [00:03,  2.79it/s]`\r\n\r\nThe way to get predictive information is to know the total amount of\r\nwork to be done. Since `os.walkdir()` cannot give us this information,\r\nwe need to precompute this by ourselves:\r\n\r\n~~~~ {.sourceCode .python}\r\ndef process_content_with_progress2(inputpath, blocksize=1024):\r\n    # Preprocess the total files count\r\n    filecounter = 0\r\n    for dirpath, dirs, files in tqdm(os.walk(inputpath)):\r\n        for filename in files:\r\n            filecounter += 1\r\n\r\n    for filepath in tqdm(walkdir(inputpath), total=filecounter):\r\n        with open(filepath, 'rb') as fh:\r\n            buf = 1\r\n            while (buf):\r\n                buf = fh.read(blocksize)\r\n                dosomething(buf)\r\n~~~~\r\n\r\n`process_content_with_progress2()` is better than the naive approach\r\nbecause now we have predictive information:\r\n\r\n`50%|████████████            | 2/4 [00:00<00:00,  4.06it/s]`\r\n\r\nHowever, the progress is not smooth: it increments in steps, 1 step\r\nbeing 1 file processed. The problem is that we do not just walk through\r\nfiles tree, but we process the files contents. Thus, if we stumble on\r\none very large file which takes a great deal more time to process than\r\nother smaller files, the progress bar will still considers that file is\r\nof equal processing weight.\r\n\r\nTo fix this, we should use another indicator than the files count: the\r\ntotal sum of all files sizes. This would be more pertinent since the\r\ndata we process is the files' content, so there is a direct relation\r\nbetween size and content.\r\n\r\nBelow we implement this approach using a manually updated `tqdm` bar,\r\nwhere `tqdm` will work on size, while the `for` loop works on files\r\npaths:\r\n\r\n~~~~ {.sourceCode .python}\r\ndef process_content_with_progress3(inputpath, blocksize=1024):\r\n    # Preprocess the total files sizes\r\n    sizecounter = 0\r\n    for dirpath, dirs, files in tqdm(os.walk(inputpath)):\r\n        for filename in files:\r\n            fullpath = os.path.abspath(os.path.join(dirpath, filename))\r\n            sizecounter += os.stat(fullpath).st_size\r\n\r\n    # Load tqdm with size counter instead of files counter\r\n    with tqdm(total=sizecounter, unit='B', unit_scale=True) as pbar:\r\n        for dirpath, dirs, files in os.walk(inputpath):\r\n            for filename in files:\r\n                fullpath = os.path.abspath(os.path.join(dirpath, filename))\r\n                with open(fullpath, 'rb') as fh:\r\n                    buf = 1\r\n                    while (buf):\r\n                        buf = fh.read(blocksize)\r\n                        dosomething(buf)\r\n                        if buf: pbar.update(len(buf))\r\n~~~~\r\n\r\nAnd here is the result: a much smoother progress bar with meaningful\r\npredicted time and statistics:\r\n\r\n`47%|████████████             | 152K/321K [00:03<00:03, 46.2KB/s]`\r\n\r\nContributions\r\n-------------\r\n\r\nAll source code is hosted on [github](https://github.com/tqdm/tqdm).\r\nContributions are welcome.\r\n\r\nSee the\r\n[CONTRIBUTE](https://raw.githubusercontent.com/tqdm/tqdm/master/CONTRIBUTE)\r\nfile for more information.\r\n\r\nLicence\r\n-------\r\n\r\nOpen Source (OSI approved):\r\n[![Licence](https://img.shields.io/pypi/l/tqdm.svg)](https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE)\r\n\r\nCitation information:\r\n[![DOI-URI](https://zenodo.org/badge/21637/tqdm/tqdm.svg)](https://zenodo.org/badge/latestdoi/21637/tqdm/tqdm)\r\n\r\nAuthors\r\n-------\r\n\r\nRanked by contributions.\r\n\r\n-   Casper da Costa-Luis (casperdcl)\r\n-   Stephen Larroque (lrq3000)\r\n-   Hadrien Mary (hadim)\r\n-   Noam Yorav-Raphael (noamraph)\\*\r\n-   Ivan Ivanov (obiwanus)\r\n-   Mikhail Korobov (kmike)\r\n\r\n\\* Original author\r\n\r\n![Readme-Hits](http://hitt.herokuapp.com/tqdm/tqdm.svg) (Since 19 May\r\n2016)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}